---
phase: 05-wizard-foundation
plan: 03
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - src/ui/wizard.js
  - src/data/storage.js
  - src/main.js
  - index.html
autonomous: false

must_haves:
  truths:
    - "User sees commune boundary on preview map before confirming"
    - "Wizard shows on first launch only (no commune config exists)"
    - "Commune config persists to localStorage on completion"
    - "Main app loads with saved commune after wizard completion"
  artifacts:
    - path: "src/ui/wizard.js"
      provides: "Boundary preview map and completion flow"
      contains: "showCommunePreview"
      min_lines: 120
    - path: "src/data/storage.js"
      provides: "Commune config save/load helpers"
      exports: ["saveCommuneConfig", "loadCommuneConfig"]
    - path: "src/main.js"
      provides: "First-launch detection and wizard initialization"
      contains: "loadCommuneConfig"
  key_links:
    - from: "src/ui/wizard.js"
      to: "Leaflet map instance"
      via: "L.map() in preview container"
      pattern: "L\\.map\\(.*preview"
    - from: "src/main.js"
      to: "src/ui/wizard.js"
      via: "initWelcomeWizard() call"
      pattern: "initWelcomeWizard\\(\\)"
    - from: "src/ui/wizard.js"
      to: "src/data/storage.js"
      via: "saveCommuneConfig() on completion"
      pattern: "saveCommuneConfig\\("
---

<objective>
Complete wizard with boundary preview, first-launch detection, and commune config persistence.

Purpose: Enable users to visually confirm their commune selection before saving configuration, implement first-launch detection to show wizard only when needed, and wire the completed wizard into main.js initialization flow.

Output: Fully functional wizard that shows on first launch, displays commune boundary preview, saves configuration to localStorage on completion, and hands off to main app.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-wizard-foundation/05-RESEARCH.md
@.planning/phases/05-wizard-foundation/05-01-SUMMARY.md
@.planning/phases/05-wizard-foundation/05-02-SUMMARY.md

# Existing patterns
@src/data/storage.js
@src/main.js
@src/data/commune.js
</context>

<tasks>

<task type="auto">
  <name>Add commune config helpers to storage.js</name>
  <files>src/data/storage.js</files>
  <action>
Add two helper functions to src/data/storage.js for commune configuration persistence.

Export saveCommuneConfig(commune) function:
```javascript
/**
 * Save commune configuration to localStorage
 * @param {Object} commune - Commune object with code, nom, contour
 * @returns {Object} Result with success boolean and optional error
 */
export function saveCommuneConfig(commune) {
  return storage.save('flyermap_commune', {
    code: commune.code,
    nom: commune.nom,
    contour: commune.contour
  });
}
```

Export loadCommuneConfig() function:
```javascript
/**
 * Load commune configuration from localStorage
 * @returns {Object|null} Commune config or null if not found
 */
export function loadCommuneConfig() {
  return storage.load('flyermap_commune');
}
```

These wrap the existing storage singleton for semantic commune-specific operations.

IMPORTANT: Save the full commune object including contour GeoJSON. Research suggests re-fetching to save quota, but for MVP simplicity and offline capability, storing the contour is acceptable (50-200KB is manageable within 5MB localStorage limit).
  </action>
  <verify>
Check src/data/storage.js exports saveCommuneConfig and loadCommuneConfig.
Verify both functions use storage.save() and storage.load() from existing singleton.
Run `grep "flyermap_commune" src/data/storage.js` - should return 2 matches.
  </verify>
  <done>
src/data/storage.js exports saveCommuneConfig and loadCommuneConfig functions.
Functions use flyermap_commune key for localStorage.
saveCommuneConfig stores code, nom, and contour fields.
  </done>
</task>

<task type="auto">
  <name>Implement boundary preview and wizard completion flow</name>
  <files>src/ui/wizard.js, index.html</files>
  <action>
Update index.html preview step to replace placeholder with map container:
```html
<div class="wz-step" data-step-name="preview">
  <h3>Confirmer votre commune</h3>
  <p id="preview-commune-name"></p>
  <div id="preview-map" style="height: 300px; border: 1px solid #ddd; margin: 1rem 0;"></div>
  <button class="wz-next-button btn-primary">Confirmer</button>
</div>
```

Import Leaflet and storage helpers in wizard.js:
```javascript
import L from 'leaflet';
import { saveCommuneConfig } from '../data/storage.js';
```

Create setupPreviewStep() function that:
1. Listens for Wizard-JS wz.update event (fires when step changes)
2. Checks if current step is preview (wizard.current_step === 2, 0-indexed)
3. Calls showCommunePreview(selectedCommune) when preview step becomes active
4. Adds click listener to next button that calls handleWizardComplete()

Implement showCommunePreview(commune) function following research pattern (lines 262-308):
1. Update preview commune name: `document.getElementById('preview-commune-name').textContent = `Commune: ${commune.nom}``
2. Get map container: `document.getElementById('preview-map')`
3. Check if map already exists (cleanup from previous preview): if (mapContainer._leafletMap) destroy it
4. Initialize Leaflet map on container:
   ```javascript
   const map = L.map(mapContainer, {
     zoomControl: true,
     attributionControl: true
   });
   ```
5. Add OSM tile layer (reuse config from main.js):
   ```javascript
   L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
     attribution: '© OpenStreetMap contributors',
     maxZoom: 19
   }).addTo(map);
   ```
6. Add commune boundary as GeoJSON layer with blue styling:
   ```javascript
   const boundaryLayer = L.geoJSON(commune.contour, {
     style: {
       color: '#3388ff',
       weight: 2,
       fillOpacity: 0.1
     }
   }).addTo(map);
   ```
7. Fit map to boundary: `map.fitBounds(boundaryLayer.getBounds(), { padding: [20, 20] })`
8. Store map reference for cleanup: `mapContainer._leafletMap = map`

Implement handleWizardComplete() function:
1. Call saveCommuneConfig(selectedCommune)
2. Check result.success - if false, show alert and return without closing
3. Clear sessionStorage wizard state (add clearWizardState() stub for now)
4. Close dialog: `document.getElementById('welcome-wizard').close()`

Add dialog close event listener in initWelcomeWizard():
```javascript
dialog.addEventListener('close', () => {
  const mapContainer = document.getElementById('preview-map');
  if (mapContainer._leafletMap) {
    mapContainer._leafletMap.remove();
    delete mapContainer._leafletMap;
  }
});
```

Call setupPreviewStep() from initWelcomeWizard() after setupPostalStep().

Add clearWizardState() stub function (sessionStorage persistence is optional for MVP):
```javascript
function clearWizardState() {
  // TODO: Implement sessionStorage cleanup if persistence added
}
```
  </action>
  <verify>
Verify index.html preview step contains div#preview-map with height: 300px.
Verify src/ui/wizard.js imports L from 'leaflet' and saveCommuneConfig.
Check for showCommunePreview and handleWizardComplete functions.
Verify dialog close listener includes map cleanup (_leafletMap.remove()).
Run `grep "fitBounds" src/ui/wizard.js` - should find map fitting code.
  </verify>
  <done>
Preview step shows commune name and boundary map.
Map displays OSM tiles with blue GeoJSON boundary.
Map fits to commune bounds automatically.
Wizard completion saves commune config to localStorage.
Map cleanup happens on dialog close.
  </done>
</task>

<task type="auto">
  <name>Wire wizard into main.js with first-launch detection</name>
  <files>src/main.js</files>
  <action>
Add first-launch detection and wizard initialization to src/main.js.

Import wizard and storage at top:
```javascript
import { initWelcomeWizard } from './ui/wizard.js';
import { loadCommuneConfig } from './data/storage.js';
```

BEFORE map initialization (before `const map = L.map(...)`), add first-launch check:
```javascript
// Check for commune configuration
const communeConfig = loadCommuneConfig();
if (!communeConfig) {
  // First launch - show wizard
  initWelcomeWizard();
  // Wizard completion will reload page, so don't initialize main app yet
  // Add event listener to initialize after wizard closes
  const dialog = document.getElementById('welcome-wizard');
  dialog.addEventListener('close', () => {
    // Re-check if commune config was saved
    if (loadCommuneConfig()) {
      window.location.reload(); // Reload to initialize main app with commune
    }
  });
  // Exit early - don't initialize map until wizard completes
  throw new Error('Wizard flow active - map initialization deferred');
}
```

This ensures:
1. If no commune config exists, wizard shows immediately
2. Main app initialization is blocked until wizard completes
3. Page reloads after wizard completion to start fresh with commune config

ALTERNATIVE (if reload feels heavy): Instead of reload, we could continue initialization after wizard closes. But reload is simpler and ensures clean state.

Update fetchCommuneBoundary() call to use saved commune config instead of hardcoded commune:
```javascript
// Use saved commune config instead of fetching
if (communeConfig.contour) {
  L.geoJSON(communeConfig.contour, {
    style: {
      color: '#2563eb',
      weight: 3,
      fillColor: '#3b82f6',
      fillOpacity: 0.1
    }
  }).addTo(map);
} else {
  // Fallback: fetch if contour not saved (shouldn't happen)
  fetchCommuneBoundary()
    .then(geojson => { /* existing code */ })
    .catch(error => { /* existing error handling */ });
}
```

Update map center to use commune config (approximate center from contour):
SKIP THIS - keep DEFAULT_CENTER from config.js for now. Computing center from GeoJSON is non-trivial. Hardcoded Chapet center is fine for v1.1.
  </action>
  <verify>
Verify src/main.js imports initWelcomeWizard and loadCommuneConfig.
Check for first-launch check before map initialization.
Verify early exit (throw or return) prevents map init when wizard shown.
Verify dialog close listener calls window.location.reload().
Check that commune boundary uses communeConfig.contour instead of fetchCommuneBoundary().
  </verify>
  <done>
main.js checks for commune config on load.
If missing, wizard displays and blocks main app initialization.
Wizard completion triggers page reload.
Reloaded page uses saved commune config for boundary.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete first-launch wizard with postal code lookup, multi-commune selection, boundary preview, and persistent commune configuration
  </what-built>
  <how-to-verify>
**Test 1: First launch flow**
1. Clear localStorage in browser DevTools: `localStorage.clear()`
2. Reload page (`Cmd+R` or `Ctrl+R`)
3. Verify wizard appears as modal overlay
4. Click "Commencer" on welcome screen
5. Enter postal code "78130"
6. Verify "Chapet" appears with "Suivant" enabled
7. Click "Suivant"
8. Verify map preview shows Chapet commune boundary (blue polygon)
9. Click "Confirmer"
10. Verify page reloads and main app loads (no wizard visible)
11. Verify map shows Chapet boundary from saved config

**Test 2: Multi-commune handling**
1. Clear localStorage: `localStorage.clear()`
2. Reload page
3. Navigate to postal step (click "Commencer")
4. Enter postal code "75001" (4 Paris arrondissements)
5. Verify 4 radio buttons appear with commune names
6. Select one commune
7. Verify "Suivant" button enables
8. Click "Suivant"
9. Verify preview map shows selected commune boundary
10. Click "Confirmer"
11. Verify page reloads with selected commune

**Test 3: Invalid postal code handling**
1. Clear localStorage and reload
2. Navigate to postal step
3. Enter "1234" (too short)
4. Verify error: "Code postal invalide (5 chiffres requis)"
5. Enter "99999" (non-existent)
6. Verify error: "Aucune commune trouvée"
7. Enter "78130" (valid)
8. Verify success and "Suivant" enabled

**Test 4: Wizard skipped on subsequent loads**
1. Complete wizard once (commune config saved)
2. Reload page
3. Verify wizard does NOT appear
4. Verify main app loads immediately with saved commune
5. Check localStorage in DevTools: verify flyermap_commune key exists with code, nom, contour

**Test 5: Map cleanup**
1. Clear localStorage and reload
2. Complete wizard to preview step
3. Click browser back button or navigate back in wizard
4. Navigate forward to preview again
5. Verify map renders correctly (no duplicate tiles or errors)
6. Open DevTools console - verify no Leaflet errors about existing map
  </how-to-verify>
  <resume-signal>
Type "approved" if all test cases pass, or describe any issues encountered
  </resume-signal>
</task>

</tasks>

<verification>
After checkpoint approval, verify:
1. localStorage contains flyermap_commune with valid JSON
2. No console errors in browser DevTools
3. Wizard HTML/CSS visually matches FlyerMap design (consistent with zoneEditor dialog)
4. Progress stepper shows correct step numbers (1/3, 2/3, 3/3)
5. Map preview displays correctly without layout issues
</verification>

<success_criteria>
- First launch (no commune config) shows wizard modal
- Postal code lookup works for valid codes
- Multi-commune selection displays radio buttons
- Preview map shows commune boundary with Leaflet
- Wizard completion saves commune config to localStorage
- Page reload after wizard loads main app with saved commune
- Subsequent page loads skip wizard (commune config exists)
- Invalid postal codes show appropriate error messages
- Map cleanup prevents Leaflet instance conflicts
</success_criteria>

<output>
After completion, create `.planning/phases/05-wizard-foundation/05-03-SUMMARY.md`
</output>
