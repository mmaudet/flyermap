---
phase: 02-team-management
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/geocoding.js
  - src/services/csvImport.js
  - package.json
autonomous: true

must_haves:
  truths:
    - "French addresses are converted to coordinates"
    - "CSV files with team member data can be parsed"
    - "Geocoding failures are reported, not silent"
  artifacts:
    - path: "src/services/geocoding.js"
      provides: "Géoplateforme API integration with rate limiting"
      exports: ["geocodeAddress", "geocodeBatch"]
    - path: "src/services/csvImport.js"
      provides: "CSV parsing with field validation"
      exports: ["parseCSV", "validateTeamMembers"]
    - path: "package.json"
      provides: "PapaParse dependency"
      contains: "papaparse"
  key_links:
    - from: "src/services/geocoding.js"
      to: "https://data.geopf.fr/geocodage"
      via: "fetch API with rate limiting"
      pattern: "data\\.geopf\\.fr"
---

<objective>
Build data processing services: Géoplateforme geocoding with rate limiting and CSV import with PapaParse.

Purpose: These services handle external data - geocoding converts addresses to map coordinates, CSV import handles user-provided team member files. Both are independent of UI and can be tested in isolation.

Output: Two service modules ready to be composed in the import pipeline.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-team-management/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install PapaParse and create CSV import service</name>
  <files>package.json, src/services/csvImport.js</files>
  <action>
Install PapaParse and create CSV import service with validation.

Step 1: Install PapaParse
```bash
npm install papaparse@^5.0.0
```

Step 2: Create src/services/csvImport.js

Requirements:
1. `parseCSV(file)` - Returns Promise that resolves to array of objects
   - Use Papa.parse with: header: true, skipEmptyLines: true, dynamicTyping: false
   - Returns Promise wrapping Papa.parse callback

2. `validateTeamMembers(members)` - Returns array of validation errors
   - Required fields: 'nom' OR 'name' (case-insensitive check)
   - Required fields: 'adresse' OR 'address' (case-insensitive check)
   - Optional fields: 'telephone', 'phone', 'tel'
   - Error format: `{row: number, field: string, message: string}`

3. `normalizeTeamMember(raw)` - Normalize field names to standard format
   - Maps nom/name/Nom/Name -> name
   - Maps adresse/address/Adresse/Address -> address
   - Maps telephone/phone/tel/Phone/Tel -> phone (optional)
   - Preserves original values, just normalizes keys

Key research insight: Accept multiple field name variations because users export from different systems.

Example structure:
```javascript
import Papa from 'papaparse';

export function parseCSV(file) {
  return new Promise((resolve, reject) => {
    Papa.parse(file, {
      header: true,
      skipEmptyLines: true,
      complete: (results) => {
        if (results.errors.length > 0) {
          reject({ type: 'PARSE_ERROR', errors: results.errors });
          return;
        }
        resolve(results.data);
      },
      error: (error) => {
        reject({ type: 'PARSE_ERROR', error });
      }
    });
  });
}

export function validateTeamMembers(members) {
  const errors = [];
  // Check each member for required fields...
  return errors;
}

export function normalizeTeamMember(raw) {
  // Normalize field names...
  return normalized;
}
```
  </action>
  <verify>
```bash
npm ls papaparse  # Shows papaparse@5.x.x
```
Create test CSV file and test in browser:
```javascript
import { parseCSV, validateTeamMembers, normalizeTeamMember } from './src/services/csvImport.js';
// Test with: nom,adresse\nJean,1 rue Test
```
  </verify>
  <done>PapaParse installed, CSV parsing returns normalized team member objects, validation catches missing required fields</done>
</task>

<task type="auto">
  <name>Task 2: Create Géoplateforme geocoding service with rate limiting</name>
  <files>src/services/geocoding.js</files>
  <action>
Create geocoding service using the NEW Géoplateforme API (NOT the deprecated api-adresse.data.gouv.fr).

CRITICAL from research:
- API endpoint: https://data.geopf.fr/geocodage/search
- GeoJSON returns [lng, lat] but Leaflet needs [lat, lng] - MUST SWAP
- Rate limit: 50 req/s = 1 request per 20ms

Requirements:

1. `geocodeAddress(address, postcode = null)` - Single address geocoding
   - Build URL with params: q, limit=1, index='address'
   - Add postcode param if provided (improves accuracy)
   - Return: `{lat, lng, label, score}` or throw Error
   - CRITICAL: Swap coordinates! API returns [lng, lat], return as {lat: coords[1], lng: coords[0]}

2. `geocodeBatch(addresses)` - Batch geocoding with rate limiting
   - addresses: array of {address, postcode?} objects
   - Process sequentially with 20ms delay between requests
   - Return array of results: `{success: true, lat, lng, label, score}` or `{success: false, error: string}`
   - Don't fail entire batch on single error - continue and report failures

3. Validate France coordinates:
   - Latitude: 41-51° (France mainland range)
   - Longitude: -5 to 10°
   - Log warning if result is outside France

Example structure:
```javascript
const BASE_URL = 'https://data.geopf.fr/geocodage/search';
const RATE_LIMIT_MS = 20;

export async function geocodeAddress(address, postcode = null) {
  const params = new URLSearchParams({
    q: address,
    limit: 1,
    index: 'address'
  });

  if (postcode) {
    params.append('postcode', postcode);
  }

  const response = await fetch(`${BASE_URL}?${params}`);
  if (!response.ok) {
    throw new Error(`Geocoding failed: ${response.status}`);
  }

  const data = await response.json();
  if (!data.features || data.features.length === 0) {
    throw new Error('Address not found');
  }

  const feature = data.features[0];
  const coords = feature.geometry.coordinates;

  // CRITICAL: GeoJSON is [lng, lat], swap for Leaflet [lat, lng]
  return {
    lat: coords[1],
    lng: coords[0],
    label: feature.properties.label,
    score: feature.properties.score || 0
  };
}

export async function geocodeBatch(addresses) {
  const results = [];
  for (let i = 0; i < addresses.length; i++) {
    try {
      const result = await geocodeAddress(addresses[i].address, addresses[i].postcode);
      results.push({ success: true, ...result });
    } catch (error) {
      results.push({ success: false, error: error.message });
    }

    // Rate limiting
    if (i < addresses.length - 1) {
      await new Promise(r => setTimeout(r, RATE_LIMIT_MS));
    }
  }
  return results;
}
```
  </action>
  <verify>
In browser console:
```javascript
import { geocodeAddress, geocodeBatch } from './src/services/geocoding.js';

// Single address (near Chapet)
const result = await geocodeAddress('1 rue de la Mairie', '78130');
console.log(result); // {lat: ~48.97, lng: ~1.93, label: '...', score: > 0.5}

// Verify lat/lng are correct (not swapped)
// Chapet is near Paris: lat ~48-49, lng ~1-2

// Batch test
const batch = await geocodeBatch([
  {address: 'Mairie de Chapet', postcode: '78130'},
  {address: 'Invalid Address XYZ123'}
]);
console.log(batch); // First: success, Second: success: false
```
  </verify>
  <done>Geocoding service calls Géoplateforme API, returns [lat, lng] coordinates (swapped from GeoJSON), handles errors gracefully in batch mode</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm ls papaparse` shows installed version 5.x
2. CSV import parses header row as field names
3. Validation catches missing 'name' or 'address' fields
4. Field normalization handles French/English variations (nom/name, adresse/address)
5. Geocoding hits data.geopf.fr (NOT api-adresse.data.gouv.fr)
6. Coordinates are correctly swapped (lat ~48-49 for Paris area, not 1-2)
7. Batch geocoding continues after individual failures
</verification>

<success_criteria>
- PapaParse parses CSV files with header detection
- Validation reports missing required fields with row numbers
- Geocoding returns coordinates in Leaflet format [lat, lng]
- Batch geocoding respects rate limit (20ms delay) and reports partial failures
- No reference to deprecated api-adresse.data.gouv.fr
</success_criteria>

<output>
After completion, create `.planning/phases/02-team-management/02-02-SUMMARY.md`
</output>
